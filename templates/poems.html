{% extends "base.html" %}
{% block content %}
<div class="poems-container">
    <h1 class="section-title">Your Poems</h1>
    
    {% if poems %}
    <div class="poems-list">
        {% for poem in poems %}
        <div class="poem-card">
            <div class="card-content">
                <h2 class="poem-title">{{ poem.title }}</h2>
                <div class="poem-date">{{ poem.date }}</div>
                <div class="poem-preview">
                    {% set preview = poem.content[:150] %}
                    {{ preview|replace('\n', ' ')|safe }}
                </div>
                <div class="poem-actions">
                    <a href="{{ url_for('view_poem', poem_id=poem.id) }}" class="btn-view">Read Poem</a>
                    <form action="{{ url_for('delete_poem', poem_id=poem.id) }}" method="post" class="inline-form">
                        <button type="submit" class="btn-delete" onclick="return confirm('Are you sure you want to delete this poem?')">Delete</button>
                    </form>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
    {% else %}
        <p class="no-poems">You haven't written any poems yet. <a href="{{ url_for('write') }}">Write your first poem</a>.</p>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Swipeable Featured Poems Logic
        const featuredContainer = document.getElementById('featured-poems');
        const indicatorContainer = document.getElementById('featured-indicator');
        
        if (featuredContainer && indicatorContainer) {
            const cards = featuredContainer.querySelectorAll('.swipe-card');
            const cardCount = cards.length;
            let activeIndex = 0;
            let startX = 0;
            let currentTranslate = 0;
            
            // Create indicator dots
            for (let i = 0; i < cardCount; i++) {
                const dot = document.createElement('div');
                dot.classList.add('indicator-dot');
                if (i === 0) dot.classList.add('active');
                indicatorContainer.appendChild(dot);
            }
            
            const updateIndicators = (index) => {
                const dots = indicatorContainer.querySelectorAll('.indicator-dot');
                dots.forEach((dot, i) => {
                    dot.classList.toggle('active', i === index);
                });
            };
            
            const goToCard = (index) => {
                if (index < 0) index = 0;
                if (index >= cardCount) index = cardCount - 1;
                
                activeIndex = index;
                updateIndicators(index);
                
                // Calculate card width including margin
                const card = cards[0];
                const style = window.getComputedStyle(card);
                const cardWidth = card.offsetWidth + parseInt(style.marginRight);
                
                currentTranslate = -index * cardWidth;
                featuredContainer.style.transform = `translateX(${currentTranslate}px)`;
            };
            
            // Touch events for swiping
            featuredContainer.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
            });
            
            featuredContainer.addEventListener('touchmove', (e) => {
                const currentX = e.touches[0].clientX;
                const diff = currentX - startX;
                const cardWidth = cards[0].offsetWidth + 16; // 16px margin
                
                // Calculate potential new position
                const newTranslate = currentTranslate + diff;
                
                // Apply bounds (don't go beyond first or last card)
                if (newTranslate > 0 || newTranslate < -cardWidth * (cardCount - 1)) {
                    return;
                }
                
                featuredContainer.style.transform = `translateX(${newTranslate}px)`;
            });
            
            featuredContainer.addEventListener('touchend', (e) => {
                const endX = e.changedTouches[0].clientX;
                const diff = endX - startX;
                const threshold = cards[0].offsetWidth * 0.3; // 30% of card width
                
                if (Math.abs(diff) > threshold) {
                    if (diff > 0 && activeIndex > 0) {
                        // Swiped right, go to previous
                        goToCard(activeIndex - 1);
                    } else if (diff < 0 && activeIndex < cardCount - 1) {
                        // Swiped left, go to next
                        goToCard(activeIndex + 1);
                    } else {
                        // Return to current card if at bounds
                        goToCard(activeIndex);
                    }
                } else {
                    // Return to current card if swipe not large enough
                    goToCard(activeIndex);
                }
            });
        }
        
        // Make poem cards clickable
        const poemCards = document.querySelectorAll('.poem-card');
        poemCards.forEach(card => {
            card.addEventListener('click', function(e) {
                // Only navigate if they didn't click on a link
                if (!e.target.closest('a')) {
                    const poemId = this.dataset.poemId;
                    window.location.href = "{{ url_for('view_poem', poem_id=0) }}".replace("0", poemId);
                }
            });
            
            // Add touch feedback
            card.addEventListener('touchstart', function() {
                this.style.transform = 'scale(0.98) translateY(-2px)';
                this.style.boxShadow = 'var(--shadow-sm)';
            });
            
            card.addEventListener('touchend', function() {
                this.style.transform = '';
                this.style.boxShadow = '';
            });
        });
    });
</script>
{% endblock %}